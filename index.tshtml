<!DOCTYPE html>
<html>
<head>
    <link rel="stylesheet" href="./styles.css">
</head>
<body>
    <canvas id="canvas" style="background-color: lightgray;"></canvas>
</body>
<script type="">
    const ctx = canvas.getContext("2d")
    let x = 0
    let y = 0
    let zoom = 1
    let currentPage: IPage

    function resizeCanvas() {
        canvas.width = this.innerWidth
        canvas.height = this.innerHeight
    }

    enum TestType {
        Hover,
        Down,
        Up
    }

    interface IElement {
        bounds: Array<Function>
        id: string
        render(): void
        onhover(): void
        onmousedown(): void
        onmouseup(): void
    }

    interface IPage {
        elements: Array<IElement>
        hitTest(x: number, y: number, type: TestType): boolean
        render(): void
    }

    interface Radius {
        topLeft: number;
        topRight: number;
        bottomLeft: number;
        bottomRight: number;
    }

    class Radius implements Radius {
        constructor(tl: number, tr: (number | null) = null, bl: (number | null) = null, br: (number | null) = null) {
            this.topLeft = tl
            this.topRight = tr ?? tl
            this.bottomLeft = bl ?? tl
            this.bottomRight = br ?? tl
        }
    }

    abstract class Page implements IPage {
        elements = new Array<IElement>

        elementUp(element: IElement) {}

        elementDown(element: IElement) {}

        elementHover(element: IElement) {}

        hitTest(x: number, y: number, type: TestType) {
            for (let i = this.elements.length - 1; i >= 0; i--) {
                let element = this.elements[i]
                if ((x > element.bounds[0]() && x < element.bounds[2]())
                    && (y > element.bounds[1]() && y < element.bounds[3]())) {
                    if (type == TestType.Hover) {
                        element.onhover()
                        this.elementHover(element)
                    }
                    else if (type == TestType.Up) {
                        element.onmouseup()
                        this.elementDown(element)

                    }
                    else if (type == TestType.Down) {
                        element.onmousedown()
                        this.elementUp(element)
                    }
                    return true
                }
            }
            
            return false
        }

        render() {
            ctx.clearRect(0, 0, canvas.width, canvas.height)
            render()

            for (let element of this.elements) {
                element.render()
            }
        }
    }

    class RoundedRect implements IElement {
        bounds: Array<Function> = []

        constructor(public id = "", public colour: string, public border: string, public radius: Radius, x: Function, y: Function,
                    width: Function, height: Function) {
            this.bounds[0] = x
            this.bounds[1] = y
            this.bounds[2] = () => x() + width()
            this.bounds[3] = () => y() + height()
        }

        onhover() {}
        onmousedown() {}
        onmouseup() {}

        render() {
            ctx.save()
            ctx.strokeStyle = this.border
            ctx.fillStyle = this.colour
            ctx.beginPath()
            ctx.moveTo(this.bounds[0]() + this.radius.topLeft, this.bounds[1]())
            ctx.lineTo(this.bounds[2]() - this.radius.topRight, this.bounds[1]())
            ctx.quadraticCurveTo(this.bounds[2](), this.bounds[1](), this.bounds[2](), this.bounds[1]() + this.radius.topRight)
            ctx.lineTo(this.bounds[2](), this.bounds[3]() - this.radius.bottomRight)
            ctx.quadraticCurveTo(this.bounds[2](), this.bounds[3](), this.bounds[2]() - this.radius.bottomRight, this.bounds[3]())
            ctx.lineTo(this.bounds[0]() + this.radius.bottomLeft, this.bounds[3]())
            ctx.quadraticCurveTo(this.bounds[0](), this.bounds[3](), this.bounds[0](), this.bounds[3]() - this.radius.bottomLeft)
            ctx.lineTo(this.bounds[0](), this.bounds[1]() + this.radius.topLeft)
            ctx.quadraticCurveTo(this.bounds[0](), this.bounds[1](), this.bounds[0]() + this.radius.topLeft, this.bounds[1]())
            ctx.closePath()
            ctx.fill()
            ctx.stroke()
            ctx.restore()
        }
    }

    class Label implements IElement {
        bounds: Array<Function> = []

        constructor(public id = "", public text: string, x: Function, y: Function, public fontSize: number = 64, public colour = "black") {
            this.bounds[0] = x
            this.bounds[1] = y
            this.bounds[2] = () => {
                ctx.save()
                ctx.font = this.fontSize + "px serif"
                let wx = x() + ctx.measureText(this.text).width
                ctx.restore()
                return wx
            }
            this.bounds[3] = () => y() + this.fontSize
        }

        onhover() {}
        onmousedown() {}
        onmouseup() {}

        render() {
            ctx.save()
            ctx.fillStyle = this.colour
            ctx.font = this.fontSize + "px serif"
            ctx.fillText(this.text, this.bounds[0](), this.bounds[1]())
            ctx.restore()
        }
    }

    class Button implements IElement {
        bounds: Array<Function> = []
        background: RoundedRect
        hovering = false
        colour = ""

        constructor(public id = "", public text: string, x: Function, y: Function, public width = () => 256, public height = () => 64, public fontSize = 32,
            public normalColour = "lightgray", public pressedColour = "darkgrey", public hoverColour = "gainsboro") {
            this.colour = this.normalColour
            this.bounds[0] = x
            this.bounds[1] = y
            this.bounds[2] = () => x() + this.width()
            this.bounds[3] = () => y() + this.height()
            this.background = new RoundedRect("", this.colour, "darkgray", new Radius(8),
                this.bounds[0], this.bounds[1], () => this.width(), () => this.height())
        }

        onhover() {
            this.background.colour = this.hoverColour
            this.render()
        }
        onmousedown() {
            this.background.colour = this.pressedColour
            this.render()
        }
        onmouseup() {
            this.background.colour = this.normalColour
            this.render()
        }

        render() {
            ctx.save()

            // Draw button background
            this.background.render()
            
            // Draw button text
            ctx.fillStyle = "#000000"
            ctx.font = this.fontSize + "px serif"
            ctx.fillText(this.text, this.bounds[0]() + 16, this.bounds[1]() + (this.height() / 2) + 16)

            ctx.restore()
        }
    }

    class MainPage extends Page {
        elements = new Array<IElement>

        constructor() {
            super()
            this.elements.push(new RoundedRect("", "#FFFFFF", "#808080", new Radius(8), () => innerWidth / 2 - Math.min(innerWidth - 16, 400) / 2, () => innerHeight / 2 - 250, () => Math.min(innerWidth - 16, 400), () => 500))
            this.elements.push(new Label("", "FlatWorld", () => innerWidth / 2 - 152, () =>  innerHeight / 2 - 164))
            this.elements.push(new Button("playBtn", "Play", () => innerWidth / 2 - 128, () =>  innerHeight / 2 + 50))
            this.elements.push(new Button("settingsBtn", "Settings", () => innerWidth / 2 - 128, () =>  innerHeight / 2 + 124))
        }

        elementUp(element: IElement) {
            switch (element.id) {
                case "playBtn":
                    console.log("Starting game")
                    currentPage = gamePage
                    currentPage.render()
                    break
                case "settingsBtn":
                    break
            }
        }

        elementDown(element: IElement) {

        }

        elementHover(element: IElement) {

        }

        roundClip(x:number, y:number, width:number, height:number, radius:number) {
            ctx.beginPath()
            ctx.moveTo(x + radius, y)
            ctx.lineTo(x + width - radius, y)
            ctx.quadraticCurveTo(x + width, y, x + width, y + radius)
            ctx.lineTo(x + width, y + height - radius)
            ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height)
            ctx.lineTo(x + radius, y + height)
            ctx.quadraticCurveTo(x, y + height, x, y + height - radius)
            ctx.lineTo(x, y + radius)
            ctx.quadraticCurveTo(x, y, x + radius, y)
            ctx.closePath()
        }

        render() {
            super.render()

            const gameIcon = new Image()
            gameIcon.src = "icon.png"
            gameIcon.addEventListener("load", (_) => {
                ctx.save()
                let x = innerWidth / 2 - 128
                let y = innerHeight / 2 - 142
                this.roundClip(x, y, 256, 178, 8)
                ctx.clip()
                ctx.drawImage(gameIcon, x, y)
                ctx.restore()
            })
        }
    }

    class GamePage extends Page {
        constructor() {
            super()
            this.elements.push(new RoundedRect("", "#FFFFFF", "#808080", new Radius(0, 8, 0, 0), () => 0, () => innerHeight - 100, () => Math.min(innerWidth - 16, 400), () => 100))
        }
    }

    // We propogate the input from the UI (foreground) to background
    function hitTest(event: any, type: TestType) {
        if (!currentPage.hitTest(event.clientX || event.touches[0].clientX,
            event.clientY || event.touches[0].clientY, type)) {
            //Handle game input
            
        }
    }

    function render() {
        ctx.save()

        for (let x = 0; x < innerWidth; x += 50) {
            for (let y = 0; y < innerHeight; y += 30) {
                ctx.fillStyle = "#4f4cb0"
                ctx.fillRect(x, y, 10, 10)
                ctx.fillStyle = "#6b93d6"
                ctx.fillRect(x + 10, y, 10, 10)
                ctx.fillStyle = "#e9eff9"
                ctx.fillRect(x + 20, y, 10, 10)
                ctx.fillStyle = "#9fc164"
                ctx.fillRect(x + 30, y, 10, 10)
                ctx.fillStyle = "#FAFFAF"
                ctx.fillRect(x, y + 10, 10, 10)
                ctx.fillStyle = "#d8c596"
                ctx.fillRect(x + 10, y + 10, 10, 10)
                ctx.fillStyle = "#9F8772"
                ctx.fillRect(x + 20, y + 10, 10, 10)
                ctx.fillStyle = "#665A48"
                ctx.fillRect(x + 30, y + 10, 10, 10)
            }
        }
        ctx.restore()
    }

    
    var mainPage = new MainPage()
    var gamePage = new GamePage()

    currentPage = mainPage
    resizeCanvas()
    currentPage.render()

    this.addEventListener("resize", () => {
        resizeCanvas()
        currentPage.render()
    })

    canvas.addEventListener("mousedown", (event) => hitTest(event, TestType.Down))
    canvas.addEventListener("touchstart", (event) => hitTest(event, TestType.Down))
    canvas.addEventListener("mousemove", (event) => hitTest(event, TestType.Hover))
    canvas.addEventListener("touchmove", (event) => hitTest(event, TestType.Hover))
    canvas.addEventListener("mouseup", (event) => hitTest(event, TestType.Up))
    canvas.addEventListener("touchend", (event) => hitTest(event, TestType.Up))
</script>
</html>