<!DOCTYPE html>
<html>
<head>
    <link rel="stylesheet" href="./styles.css">
</head>
<body>
    <canvas id="canvas" style="background-color: lightgray;"></canvas>
</body>
<script>
    const ctx = canvas.getContext("2d")
    var currentPage: IPage

    function resizeCanvas() {
        canvas.width = this.innerWidth
        canvas.height = this.innerHeight
    }

    enum TestType {
        Hover,
        Down,
        Up
    }

    interface IElement {
        bounds: Array<Function>
        id: string
        render()
        onhover()
        onmousedown()
        onmouseup()
    }

    interface IPage {
        elements: Array<IElement>
        hitTest(x: number, y: number, type: TestType): boolean
        render()
    }

    interface Radius {
        topLeft: number;
        topRight: number;
        bottomLeft: number;
        bottomRight: number;
    }

    class Radius implements Radius {
        constructor(tl: number, tr: (number | null) = null, bl: (number | null) = null, br: (number | null) = null) {
            this.topLeft = tl
            this.topRight = tr ?? tl
            this.bottomLeft = bl ?? tl
            this.bottomRight = br ?? tl
        }
    }

    abstract class Page implements IPage {
        elements = new Array<IElement>

        elementUp(element: IElement) {}

        elementDown(element: IElement) {}

        elementHover(element: IElement) {}

        hitTest(x: number, y: number, type: TestType) {
            for (let i = this.elements.length - 1; i >= 0; i--) {
                let element = this.elements[i]
                if ((x > element.bounds[0]() && x < element.bounds[2]())
                    && (y > element.bounds[1]() && y < element.bounds[3]())) {
                    if (type == TestType.Hover) {
                        element.onhover()
                        this.elementHover(element)
                    }
                    else if (type == TestType.Up) {
                        element.onmouseup()
                        this.elementDown(element)

                    }
                    else if (type == TestType.Down) {
                        element.onmousedown()
                        this.elementUp(element)
                    }
                    return true
                }
            }
            
            return false
        }

        render() {
            ctx.clearRect(0, 0, canvas.width, canvas.height)

            for (let element of this.elements) {
                element.render()
            }
        }
    }

    class RoundedRect implements IElement {
        bounds: Array<Function> = []

        constructor(public colour: string, public border: string, public radius: Radius, x: Function, y: Function,
                    width: Function, height: Function, public id = "") {
            this.bounds[0] = x
            this.bounds[1] = y
            this.bounds[2] = () => x() + width()
            this.bounds[3] = () => y() + height()
        }

        onhover() {}
        onmousedown() {}
        onmouseup() {}

        render() {
            ctx.save()
            ctx.strokeStyle = this.border
            ctx.fillStyle = this.colour
            ctx.beginPath()
            ctx.moveTo(this.bounds[0]() + this.radius.topLeft, this.bounds[1]())
            ctx.lineTo(this.bounds[2]() - this.radius.topRight, this.bounds[1]())
            ctx.quadraticCurveTo(this.bounds[2](), this.bounds[1](), this.bounds[2](), this.bounds[1]() + this.radius.topRight)
            ctx.lineTo(this.bounds[2](), this.bounds[3]() - this.radius.bottomRight)
            ctx.quadraticCurveTo(this.bounds[2](), this.bounds[3](), this.bounds[2]() - this.radius.bottomRight, this.bounds[3]())
            ctx.lineTo(this.bounds[0]() + this.radius.bottomLeft, this.bounds[3]())
            ctx.quadraticCurveTo(this.bounds[0](), this.bounds[3](), this.bounds[0](), this.bounds[3]() - this.radius.bottomLeft)
            ctx.lineTo(this.bounds[0](), this.bounds[1]() + this.radius.topLeft)
            ctx.quadraticCurveTo(this.bounds[0](), this.bounds[1](), this.bounds[0]() + this.radius.topLeft, this.bounds[1]())
            ctx.closePath()
            ctx.fill()
            ctx.stroke()
            ctx.restore()
        }
    }

    class Label implements IElement {
        bounds: Array<Function> = []

        constructor(public text: string, public colour: string, public fontSize: number, x: Function, y: Function, public id = "") {
            this.bounds[0] = x
            this.bounds[1] = y
            this.bounds[2] = x
            this.bounds[3] = y
        }

        onhover() {}
        onmousedown() {}
        onmouseup() {}

        render() {
            ctx.save()
            ctx.fillStyle = this.colour
            ctx.font = this.fontSize + "px serif"
            ctx.fillText(this.text, this.bounds[0](), this.bounds[1]())
            ctx.restore()
        }
    }

    class Button implements IElement {
        bounds: Array<Function> = []
        width = 256
        height = 64
        hovering = false

        constructor(public text: string, public colour: string, x: Function, y: Function, public id = "") {
            this.bounds[0] = x
            this.bounds[1] = y
            this.bounds[2] = () => x() + this.width
            this.bounds[3] = () => y() + this.height
        }

        onhover() {}
        onmousedown() {}
        onmouseup() {}

        render() {
            ctx.save()

            // Draw button background
            ctx.fillStyle = this.colour
            ctx.fillRect(this.bounds[0](), this.bounds[1](), this.width, this.height)
            
            // Draw button text
            ctx.fillStyle = "#000000"
            ctx.font = "32px serif"
            ctx.fillText(this.text, this.bounds[0]() + 16, this.bounds[1]() + (this.height / 2) + 16)

            // Draw hover

            ctx.restore()
        }
    }

    class MainPage extends Page {
        elements = new Array<IElement>

        constructor() {
            super()
            this.elements.push(new RoundedRect("#FFFFFF", "#808080", new Radius(8), () => innerWidth / 2 - Math.min(innerWidth - 16, 400) / 2, () => innerHeight / 2 - 250, () => Math.min(innerWidth - 16, 400), () => 500))
            this.elements.push(new Label("FlatWorld", "#000000", 64, () => innerWidth / 2 - 152, () =>  innerHeight / 2 - 96))
            this.elements.push(new Button("Play", "lightgray", () => innerWidth / 2 - 128, () =>  innerHeight / 2 - 32, "playBtn"))
            this.elements.push(new Button("Settings", "lightgray", () => innerWidth / 2 - 128, () =>  innerHeight / 2 + 48, "settingsBtn"))
        }

        elementUp(element: IElement) {
            switch (element.id) {
                case "playBtn":
                    console.log("Starting game")
                    currentPage = gamePage
                    currentPage.render()
                    break
                case "settingsBtn":
                    break
            }
        }

        elementDown(element: IElement) {

        }

        elementHover(element: IElement) {

        }
    }

    class GamePage extends Page {
        constructor() {
            super()
        }
    }

    resizeCanvas()
    
    var mainPage = new MainPage()
    var gamePage = new GamePage()

    currentPage = mainPage
    currentPage.render() //MouseEvent.prototype.clientX 

    // We propogate the click from the UI (foreground) to background
    function hitTest(event: any, type: TestType) {
        if (!currentPage.hitTest(event.clientX || event.touches[0].clientX,
            event.clientY || event.touches[0].clientY, type)) {
            //Handle game input
            
        }
    }

    this.addEventListener("resize", () => {
        resizeCanvas()
        currentPage.render()
    })

    canvas.addEventListener("mousedown", (event) => hitTest(event, TestType.Down))
    canvas.addEventListener("touchstart", (event) => hitTest(event, TestType.Down))
    canvas.addEventListener("mousemove", (event) => hitTest(event, TestType.Hover))
    canvas.addEventListener("touchmove", (event) => hitTest(event, TestType.Hover))
    canvas.addEventListener("mouseup", (event) => hitTest(event, TestType.Down))
    canvas.addEventListener("touchend", (event) => hitTest(event, TestType.Up))
</script>
</html>